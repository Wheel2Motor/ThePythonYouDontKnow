# 命令行参数解析

## 「argparse」模块与「getopt」模块

在没有自动化的命令行参数解析器的情况下，当我们要手动对一个程序的命令行参数进行解析，不得不考虑很多问题。

- 哪些参数是个开关flag？
- 哪些参数必须提供？
- 哪些参数得有值？需要多少个值？
- 哪些参数是什么类型？需要怎么做转换？

对这些参数的手动处理逻辑会变得非常混乱、代码难以维护、容易出现意料之外的使用方式引发的Bug......

于是我们需要一些现成的框架，让开发者遵循一定的标准与规则，让用户输入错误时能够得到准确的提示。

好在这样的框架在Python标准库中就提供了，Python标准库中有两个命令行参数解析模块，一个是的 `argparse` 模块，另一个是 `getopt` 模块。

- **argparse**
> 现代化、灵活、强大。

- **getopt**
> 精简，易用，Unix下C程序的传统开发风格。

> 标准库中也曾经也存在过 `optparse` 模块，但其最终被 `argparse` 取代，已经于Python3.2中被标记废弃：`The optparse module is deprecated and will not be developed further; development will continue with the argparse module` 。

## 参数与参数的值

命令行程序有些不需要任何参数即可使用，如 `pwd` 用于打印当前工作路径。

有些程序需要提供一些类似开关性质的参数，如 `python -v` 用于打印python的版本。

有些程序不仅需要提供参数，还要为参数提供值，如 `python -m pip` 用于调用pip模块。

## 参数的「短名」与「长名」

从命令行参数的习惯上来说，类Unix-Like系统下通常用类似 `-f` 表示一个参数的缩写，也就是「短名」，一般 `-` 后的部分只用一个字母，但用多个字母也没关系，它的目的只是作为完整参数名称的缩写；用 `--foo` 表示完整参数名称，也就是「长名」。在实际使用时， `-f` 和 `--foo` 指向同一个参数。

另外对于多个单词构成的参数名称而言，习惯上用 `-` (hyphen)作为分隔。
例如：

```shell
prg --compress-level
```

在Windows下则没有固定的约定或规范，但依然可以用Unix-Like下的这套约定俗成的习惯。

## 「选项参数」

有一类参数，需要先指定名称，再提供值，它们叫作「选项」。

由于需要指定名称，所以选项的顺序可以不作要求，它就像在Python中关键字参数可以乱序提供一般。

如下案例中， `-o` 就是选项， `a.out` 就是 `-o` 的值； `-c` 就是选项， `main.c` 就是 `-c` 的值。

```shell
gcc -o a.out -c main.c
```

习惯上不需要值的参数叫「flag选项」，即指定了就是「开」，没有指定就是「关」；需要值的参数叫「带值选项」，即参数后面可以带上一个或多个值。

案例如下： `-fPIC` 和 `-g` 就是flag选项； `-c` 就是个带值选项，它的值是 `test.c` 。

```shell
gcc -c test.c -fPIC -g
```

带值选项在一些框架下，还可以写成 `--{Option}={Value}` 的形式，比如本文将要提到的 `argparse` 和 `getopt` 就都支持。

## 「位置参数」

故名思义，它像C语言中函数的参数列表一样，只能按参数定义的顺序提供参数的值。

它在使用时不需要指定名称，只需要提供值即可。提供值的顺序也是有严格的要求的，要按照程序中预定义的顺序提供。

案例如下，在指定要编译的源码时，并不需要指定参数名称，gcc会知道后续的参数都是它要编译的文件名。

```shell
gcc a.c b.c c.c d.c
```

位置参数的指定也会有些不成文的要求，这些要求不需要记住，只要从逻辑上对它们进行分析就会知道可以和不可以这么做的合理性。

- 位置参数只能有一个。
> 比如一个程序有两个参数，一个参数是alist，一个参数是blist，它们都要求输入不定数量的值作为列表，那么问题来了：何处是它们两个列表的分界？
> `myprogram a.c b.c c.c d.py e.py f.py`

- 位置参数的值不要和某个选项的名称冲突。
> 如果你有个文件需要加入列表进行处理，但它的名称叫 `-l` ，那么它到底是 `-l` 选项还是叫 `-l` 的文件？
> `myprogram a.c b.c -l.c`

---

# argparse模块

## 概览

### 学习思路

`argparse` 的参数类型和组合方式多且杂，很难在单独学习的情况下学明白，建议结合实际情景进行学习。

```mermaid
flowchart LR
A("我想要做什么") --> B("该怎么做到")
```

### 使用套路

`argparse` 中最重要的类 `ArgumentParser` 有一些基本的使用「套路」，适用于其所有类型参数的定义和解析。

```mermaid
flowchart LR
A("实例化解析器") --> B("定义参数") --> C("解析参数")
```

```python
# 生成解析器
parser = argparse.ArgumentParser([ParserConfig...])
# 定义参数
parser.add_argument(ShortName, LongName, [OtherOption...])
# 解析参数
args = parser.parse_args()
# 获取参数
foo = args.foo
bar = args.bar
```

#### 实例化解析器

在实例化 `ArgumentParser` 时指定解析器的一些参数，比如程序名称、描述文本之类。

```python
parser = argparse.ArgumentParser(
    prog="Your Program Name",
    description="Some introduction text",
    )
```

#### 定义参数

在 `parser.add_argument` 中添加的「短名」是以 `-` 开头的，「长名」是以 `--` 开头的。解析完成后获取参数时，参数的名称并不包含开头的一个或两个 `-` ，如果长短名中通过 `-` 分隔多个单词，在解析结果中的名称，也会被统一转换为 `_` ，以匹配Python变量名称的要求。

例：

```python
parser.add_argument("-f", "--foo-bar")
args = parser.parse_args()
foo_bar = args.foo_bar
```

「短名」和「长名」的首字母即使没有关系也不影响，最终参数的名称以长名称为准。

```python
parser.add_argument("-l", "--compress-level")
args = parser.parse_args()
cl = args.compress_level
```

```shell
python yourscript.py -l 9
```

可以看到 `--compress-level` 在解析结果中变成了 `compress_level` 。

解析的析果是个 `Namespace` 类型，类似于 `dataclass` 的数据类性质。

```python
args = parser.parse_args()
```

#### 解析参数

最后用parser对命令行参数列表进行解析。

> 由于 `sys.argv[0]` 是程序名称，所以 `argparse` 默认会用 `sys.argv[1:]` 进行解析。
但我们还可以手动输入一个列表作为第一个参数让它解析。


### 特性

#### 语法糖

 `argparse` 提供了一些语法糖。

- --{Option}={Value}
> `argparse` 支持在提供带值选项时，以两种方式为选项提供值。方法一： `--option value` ；方法二： `--option=value` 。

- 缩写
> 如果一个选项的名称中开头几个字母和其它选项的名称不会冲突，那么完全可以只输入它的前几个字母，比如一个参数叫 `--foo` ，我们可以直接输入 `--fo` 。

#### 缺陷

`argparse` 也有一些缺陷，这些缺陷容易给新手带入坑中。

- 明明不支持多个位置参数，却不会报错
> 在本文后面即将学习的 `getopt` 模块中，直接在机制上决定了位置参数只能有一个（解析结果的第2个值是位置参数列表），但 `argparse` 居然可以定义多个位置参数，且不报错。

- 添加参数时的某些设置支持多种不同类型的值
> 比如 `nargs` ，它可以是整数，也可以是某些特定字符；再比如 `const` ，它可以是任何Python对象。这些特定语境下的使用方式无疑大大增加了了学习难度。

### 常用参数选项

`argparse` 模块最迷惑的地方就在于其 `add_argument` 拥有众多参数，每个参数的类型多变且不同组合得到的结果也不同。

- **action**
> 当用户提供该参数时的行为，是个字符串。比如有些参数只能是 `true` 或 `false` ，当用户提供了选项，自动认为是 `True` 或 `False` 。

- **const**
> 在 `action` 或 `nargs` 为某些特定的值时，会需要的一个额外参数。通常用于一旦参数被提供时得到的值。它还可以配合 `default` 以达到二元 `choices` 的flag效果。

- **metavar**
> 用于提供更友好的帮助信息。

- **type**
> 命令行参数的类型，argparse会尝试自动做类型转换，在转换失败时也会提供较为友好的报错信息。

- **nargs**
> 约束参数的值的数量，并在用户提供了错误的参数数量时给出较为友好的报错提醒。

- **choices**
> 指定该参数的值只能是预定义的选项中的一个，不可以是其它文本内容。

- **required**
> 指定该参数是否必须输入。

- **dest**
> 该参数给到解析结果时的名称，参数名称和解析结果的名称可以不同，也就是说 `--foo` 在解析结果中，可以输出到名为 `bar` 的属性上去。

- **default**
> 该参数在没有指定值时的默认值。

- **help**
> 参数的帮助文本，在 `python yourscript.py --help` 时或输入参数格式错误时，会自动打印帮助文本。

## 案例

### 最简单的命令行参数解析

默认情况下， `ArgumentParser` 的 `add_argument` 方法头两个参数分别是参数的「短名」和「长名」，参数默认支持1个参数。

```python
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("-f", "--foo")
args = parser.parse_args()
print("Foo: ", args.foo)
```

```shell
python yourscript.py -f 123
# Foo: 123
python yourscript.py -foo 234
# Foo: 234
python yourscript.py
# Foo: None
```

你也可以只提供「短名」或只提供「长名」，此时在输入参数的时候必须严格按照代码里提供的唯一的「短名」或「长名」来提供参数，解析的结果中也只能通过那唯一提供的名称来得到参数，程序不会自动补充出来缺失的「短名」或「长名」。

> 这里容易犯的一个错误就是，一些人会以为只定义 `--foo` ，会自动实现 `-f` 的解析，其实不会。试想一个程序中有多个 `f` 开头的参数名称，此时一旦出现了自动定义的行，是不是会冲突。

```python
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("-f")
parser.add_argument("--bar")
args = parser.parse_args()
print("Foo: ", args.f)
print("Bar: ", args.bar)
```

```shell
python yourscript.py -f 123 --bar 234
# Foo: 123
# Bar: 234
```

另外还有个语法糖：如果「短名」只有一个字母，那么「短名」可以和值连在一块，中间不写空格也问题不大。

```shell
python yourscript.py -f123 --bar 234
# Foo: 123
# Bar: 234
```

### 给程序添加介绍性文本

介绍文本和程序名称可以在实例化 `ArgumentParser` 时指定。
 `argparse` 会自动实现一个默认的帮助参数，可以通过 `-h` 或 `--help` 打印出来。

> `-h` 和 `--help` 表示打印帮助信息，是Unix-Like下的习俗，在实际编程中也应当尽量遵守，这样可以让不会使用程序的人，在第一时间找到帮助信息。

```python
import argparse

parser = argparse.ArgumentParser(prog="hello", description="Hello World!")
parser.add_argument("-f", "--foo")
parser.add_argument("-b", "--bar")
args = parser.parse_args()
```

```shell
python yourscript.py -h
# usage: hello [-h] [-f FOO] [-b BAR]
# Hello World!
# options:
#   -h, --help         show this help message and exit
#   -f FOO, --foo FOO
#   -b BAR, --bar BAR
```

- **prog**
> 程序的名称，默认情况下会是 `sys.argv[0]` 。

- **description**
> 程序的描述性文本。

其它参数还有这些常用的：

- **add_help**
> 自动添加 `-h/--help` 参数用于打印帮助。默认为 `True` 。

- **allow_abbrev**
> 「长名」允许使用缩写，只要不出来歧义，比如 `--foo` 在没有其它 `--f...` 开头的参数时，只输入 `--f` 也可以。默认为 `True` 。

`ArgumentParser` 还有很多其它参数，这里不一一展开，可以在Python官方文档中进行查看。

### 给参数参数添加帮助文本

参数的帮助文本在 `add_argument` 里添加，同样是在打印程序的帮助信息时一起显示出来。

```python
import argparse

parser = argparse.ArgumentParser("Hello Wrold!")
parser.add_argument("-f", "--foo", help="This is foo.")
parser.add_argument("-b", "--bar", help="This is bar.")
args = parser.parse_args()
```

```shell
python yourscript.py --help
# usage: Hello Wrold! [-h] [-f FOO] [-b BAR]
# options:
#   -h, --help         show this help message and exit
#   -f FOO, --foo FOO  This is foo.
#   -b BAR, --bar BAR  This is bar.
```

### 用户没有指定参数的情况下自动打印帮助

如果有时候希望在用户没有指定参数的情况下自动打印帮助，而不是看到 `argparse` 报错说参数不正确，可以手动输入解析的参数列表，在 `parser.parse_args(sys.argv[1:])` 前拦截解析的行为。

```python
import sys
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("-f", "--foo")
if not sys.argv[1:]:
    parser.print_help()
    sys.exit(0)
args = parser.parse_args(sys.argv[1:])
print("Foo: ", args.foo)
```

```shell
python yourscript.py
# usage: yourscript.py [-h] [-f FOO]
# options:
#   -h, --help         show this help message and exit
#   -f FOO, --foo FOO
```

### 布尔开关flag选项解析

需要在 `action` 参数上写上 `store_true` 或 `store_false` ，相当于提供了参数的情况下为开关填写对应的值，没有提供的情况下自动填写相反的值。

- **store_true**: 如果提供了该flag，则值为 `True` ，否则为 `False` 。
- **store_false**: 如果提供了该flag，则值为 `False` ，否则为 `True` 。

```python
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("-f", "--foo", action="store_true")
parser.add_argument("-b", "--bar", action="store_false")
args = parser.parse_args()
print("Foo: ", args.foo)
print("Bar: ", args.bar)
```

```shell
python yourscript.py
# Foo: False
# Bar: True
python yourscript.py -f -b
# Foo: True
# Bar: False
```

### 强制要求用户提供参数

如果一个参数是必需要用户提供的，可以用到 `required` 选项，该选项的值是 `True` 或 `False` 。默认情况下该参数为 `False` ，表示不强制要求用户输入对应的参数。

```python
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("-f", "--foo", required=True)
args = parser.parse_args()
print("Foo: ", args.foo)
```

```shell
python yourscript.py
# yourscript.py: error: the following arguments are required: -f/--foo
python yourscript.py -f 123
# Foo: 123
```

### 限定参数值的范围

以数据压缩为例，需要输入是否启用压缩，它的值只能是 `yes` 或 `no` 。

```python
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("-ci", "--compress-it", choices=["yes", "no"])
args = parser.parse_args()
print("Compress It: ", args.compress_it)
```

```shell
python yourscript.py -ci yes
# Compress It: yes
python yourscript.py --compress-it no
# Compress It: no
```

### 指定参数类型

以数据压缩为例，需要输入一个压缩等级，它的值是个整数。

```python
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("-l", "--compress-level", type=int)
args = parser.parse_args()
print("Compress Level: ", args.compress_level)
```

```shell
python yourscript.py -l 1
# Compress Level: 1
```

如果要限制一下压缩等级的范围，可以将 `choices` 和 `type` 混合使用。

```python
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("-l", "--compress-level", type=int, choices=range(10))
args = parser.parse_args()
print("Compress Level: ", args.compress_level)
```

```shell
python yourscript.py -l
# usage: yourscript.py [-h] [-l {0,1,2,3,4,5,6,7,8,9}]
# yourscript.py: error: argument -l/--compress-level: expected one argument
python yourscript.py -l 9
# Compress Level: 9
```

限定参数类型会有个坑点，如果没有指定该参数为 `required` ，那么用户不输入该参数时，解析的结果为 `None` ，即使指定了该参数的类型为 `int` 也依旧不会报错。所以严谨的写法如下：
```python
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("-l", "--compress-level",
    type=int,
    choices=range(10),
    required=True,
    )
args = parser.parse_args()
print("Compress Level: ", args.compress_level)
```

在指定 `choices` 为一个整数列表时，也要注意指定类型为 `int` ，否则即使输入的值看上去对，也会报错说 `invalid choice` ，因为在没指定参数类型的情况下，输入的值都会按照字符串进行处理，也就是说 `"1" != 1` 导致了这样的报错。

```shell
python yourscript.py -l 9
# usage: yourscript.py [-h] [-l {0,1,2,3,4,5,6,7,8,9}]
# yourscript.py: error: argument -l/--compress-level: invalid choice: '9' (choose # from 0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
```

`argparse` 还可以知能地将字符串转为 `pathlib.Path` 对象，用于更严谨的路径操作。

```python
import argparse
from pathlib import Path

parser = argparse.ArgumentParser()
parser.add_argument("-f", "--file", type=Path)
args = parser.parse_args()
print(type(args.file))
```

```shell
python yourscript.py -f yourscript.py
# <class 'pathlib.WindowsPath'>
```

`argparse` 还能智能地打开文件，直接得到文件对象，需要使用 `argparse.FileType` 类，传给它的参数都会传递到 `open` 函数中使用，所以参数和打开文件使用的参数一致。

```python
import argparse
from pathlib import Path

parser = argparse.ArgumentParser()
parser.add_argument("-r", "--read",
    type=argparse.FileType('r', encoding="utf8"),
    required=True,
    )
parser.add_argument("-w", "--write",
    type=argparse.FileType('w', encoding="utf8"),
    required=True,
    )
args = parser.parse_args()
fr = args.read
fw = args.write
nbytes = fw.write(fr.read())
fr.close()
fw.close()
print(f"Wrote {nbytes} bytes")
```

```shell
python yourscript.py -r yourscript.py -w out.py
# Wrote 440 bytes
```

### 为参数指定默认值

可以通过 `default` 选项为参数指定默认值。

它的行为与 `required = True` 是互斥的，不过很不幸的是， `argparse` 并没有帮我们在定义的时候识别出来这两个参数的互斥行为，也就是说，你完全可以在指定了 `required = True` 的情况下再指定个 `default = 6` ，结果就是 `default` 指定了也是白指定了。

```python
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("-l", "--compress-level",
    type=int,
    choices=range(10),
    default=6,
    )
args = parser.parse_args()
print("Compress Level: ", args.compress_level)
```

```shell
python yourscript.py
# Compress Level: 6
python yourscript.py -l 9
# Compress Level: 9
```

### 为参数的值指定到另一个名称的变量上

有时候当程序规模大起来后，在大量参数存在的情况下，总有些名称被占用了，此时需要重新为参数在命令行中取一个还没用过的名称，但在代码逻辑中因为可维护性等原因，不希望用这个临时起的名称作为参数，此时可以用上 `dest` 选项。

```python
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("-f", "--foo", dest="bar")
args = parser.parse_args()
print("Bar: ", args.bar)
```

```shell
python yourscript.py -f abc
# Bar: abc
```

### flag选项一旦提供就得到特定的值

flag选项并非只能得到 `True` 或 `False` ，也可以自动得到一个预定义好的常量值。

可以为 `action` 指定`store_const` ，此时就会需要再指定一个选项 `const` 。当用户提供了该flag选项时，它的解析结果是之前在 `const` 上指定的常量；当用户没有提供该flat参数时，该flag选项的值是 `None` 。

```python
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("-f", "--foo", action="store_const", const=123)
args = parser.parse_args()
print("Foo: ", args.foo)
```

```shell
python yourscript.py
# Foo: None
python yourscript.py -f
# Foo: 123
python yourscript.py --foo
# Foo: 123
```

如果 `store_const` 与 `const` 的配合只是能存储简单的数字、字符串那就意义不大了，它其实还可以存放任何Python对象，不限类型。

> 使用 `action="store_const"` 配合 `const` 与 `default` 做到。

```python
import argparse

parser = argparse.ArgumentParser(description="Number processor")
parser.add_argument('--sum', action="store_const", const=sum, default=max)
parser.add_argument('-a', type=int, required=True)
parser.add_argument('-b', type=int, required=True)
args = parser.parse_args()

if args.sum is sum:
    print(f"Sum of {args.a} and {args.b}: {args.sum([args.a, args.b])}")
else:
    print(f"Max of {args.a} and {args.b}: {args.sum([args.a, args.b])}")
```

```shell
python yourscript.py -a 1 -b 2
# Max of 1 and 2: 2
python yourscript.py -a 1 -b 2 -sum
# Sum of 1 and 2: 3
```

### 需要控制参数的值的数量

通过 `nargs` 可以限制一个参数的值的数量。

#### 确定数量的值

可以给 `nargs` 指定一个整数，表明这个参数需要N个值，它们会被收集为一个列表。

比如 `nargs=3` ，表明这个参数有3个值.

```python
import argparse

parser = argparse.ArgumentParser()
parser.add_argument('-f', "--foo", nargs=3)
args = parser.parse_args()
print(args)
```

```shell
python yourscript.py -f 1 2 3
# [1, 2, 3]
```

#### 可选的一个值

可以给 `nargs` 指定为 '?' ，表明该参数可以最多消耗掉一个值。

意思就是说该参数可以单指定名称但不提供值，或者指定名称后提供最多一个值。

此时我们还可以指定 `const` 为某个值，用于单指定名称但不提供值时得到的默认值。

```python
import argparse

parser = argparse.ArgumentParser()
parser.add_argument('-f', "--foo", nargs='?', const="abc")
args = parser.parse_args()
print("Foo: ", args.foo)
```

```shell
python yourscript.py
# Foo: None
python yourscript.py -f
# Foo: abc
python yourscript.py -f 123
# Foo: 123
```

#### 至少一个值

可以给 `nargs` 指定为 `'+'` ，表明至少要求一个值，它们会被收集为一个列表。

```python
import argparse

parser = argparse.ArgumentParser()
parser.add_argument('-f', "--foo", nargs='+')
args = parser.parse_args()
print(args)
```

```shell
python yourscript.py -f 1
# [1]
python yourscript.py -f 1 2
# [1, 2]
python yourscript.py -f 1 2 3
# [1, 2, 3]
```

#### 零到不定数量的值

可以给 `nargs` 指定为 `'*'` ，表明至少零到不定数量的值，它们会被收集为一个列表。

```python
import argparse

parser = argparse.ArgumentParser()
parser.add_argument('-f', "--foo", nargs='*')
args = parser.parse_args()
print(args)
```

```shell
python yourscript.py -f
# []
python yourscript.py -f 1
# [1]
python yourscript.py -f 1 2
# [1, 2]
```

注意，此时如果不提供 `-f` 参数，并不是得到一个空列表，而是得到 `None` ，需要在不指定参数时得到空列表，仍需要提供选项 `required=True` 。

### 可以忽略、可以当作flag选项、也可以当作带值选项

如果某种参数，它希望它可以在不指定时使用A默认值，指定为开关时使用B默认值，如果A和B都不理想还可以输入一个值对它进行覆盖，这种也是可以做到的。

> 使用 `nargs='?'` 配合 `const` 与 `default` 做到。

```python
import argparse

parser = argparse.ArgumentParser(description="Your Compressor")
parser.add_argument('-l', '--compress-level', nargs='?', type=int, const=9, default=0)
args = parser.parse_args()

compress_level = args.compress_level
if compress_level == 0:
    print("Skip compression")
elif compress_level == 9:
    print("Ultra compression")
else:
    print(f"Compress level: {compress_level}")
```

```shell
python yourscript.py
# Skip compression
python yourscript.py -l
# Ultra compression
python yourscript.py -l 3
# Compression level: 3
```

### 使用位置参数

位置参数在使用的时候可以不需要像 `--arg-name` 这样指定名称。

这种参数在添加参数时，名称里不要以 `-` 开头即可。

```python
import argparse

parser = argparse.ArgumentParser(description="Your compressor")
parser.add_argument("files", nargs='+')
args = parser.parse_args()
for f in args.files:
    print(f"Compressing file: {f}")
```

```shell
python yourscript.py file1.py file2.py file3.py
# Compressing file: file1.py
# Compressing file: file2.py
# Compressing file: file3.py
```

如果我们打印程序的帮助信息，会发现位置参数在 `positional arguments` 分组里；「选项」在 `options` 分组里。

```python
import argparse

parser = argparse.ArgumentParser(description="Your compressor")
parser.add_argument("files", nargs='+')
parser.add_argument("-l", "--compress-level",
    default=6,
    type=int,
    choices=range(10),
    help="Compressing level, 0 meas no compression, 9 means ultra."
    )
args = parser.parse_args()
for f in args.files:
    print(f"Compressing file: {f}")
```

```shell
# usage: yourscript.py [-h] [-l {0,1,2,3,4,5,6,7,8,9}] files [files ...]
# Your compressor
# positional arguments:
#  files
# options:
#   -h, --help   show this help message and exit
#   -l {0,1,2,3,4,5,6,7,8,9}, --compress-level {0,1,2,3,4,5,6,7,8,9}
#                Compressing level, 0 meas no compression, 9 means ultra.
```

### 更友好的帮助提示信息

默认情况下， `argparse` 会用参数名称自动生成一些帮助文本，如果我们觉得不具备足够的可读性，可以用 `metavar` 覆盖文本。

比如位置参数 `files` 需要至少一个参数，它的帮助文本如下。

```python
import argparse

parser = argparse.ArgumentParser(description="Your compressor")
parser.add_argument("-l", "--compress-level", type=int, default=6)
parser.add_argument("files", nargs='+')
args = parser.parse_args()
print("Compress level: ", args.compress_level)
for f in args.files:
    print("Compressing file: ", f)
```

```shell
python yourscript.py -h
# usage: Your compressor [-h] [-l COMPRESS_LEVEL] files [files ...]
# positional arguments:
#   File
# options:
#   -h, --help            show this help message and exit
#   -l COMPRESS_LEVEL, --compress-level COMPRESS_LEVEL
```

当我们给 `files` 参数指定了 `metavar="File"` 后可以看到输出文本发生了改变。

```python
import argparse

parser = argparse.ArgumentParser(description="Your compressor")
parser.add_argument("-l", "--compress-level", type=int, default=6)
parser.add_argument("files", nargs='+', metavar="File")
args = parser.parse_args()
print("Compress level: ", args.compress_level)
for f in args.files:
    print("Compressing file: ", f)
```

```shell
python yourscript.py -h
# usage: Your compressor [-h] [-l COMPRESS_LEVEL] File [File ...]
# positional arguments:
#   File
# options:
#   -h, --help            show this help message and exit
#   -l COMPRESS_LEVEL, --compress-level COMPRESS_LEVEL
```

帮助信息中 `files [files ...]` 变成了 `File [File ...]` 。

当一个参数的帮助形如 `File [File ...]` 则说明它要求提供至少一个值。
当一个参数的帮助形如 `[File ...]` 则说明它要求提供零到多个值。

### 多次指定参数，拼接到同一个列表

`argparse` 也支持多次指定同一个参数，将值拼接到一个列表中，可以通过 `action` 来实现。

#### 每次只能指定一个值

当 `action="append"` 时，参数可以指定多次，每次只能指定为一个值，相当于有一个空列表，每次指定该参数时会append进去一个元素。

```python
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("-f", "--foo", action="append")
args = parser.parse_args()
print(args.foo)
```

```shell
python yourscript.py --foo main.c --foo utils.c
# ["main.c", "utils.c"]
```

#### 每次指定不定数量的值

还可以让 `action="extend"` ，参数可以指定多次，但是每次只能指定为超过一个值，相当于有一个空列表，每次指定该参数时会将当次的参数列表extend进去。

不过此时要注意给 `nargs` 指定为 `+` 或 `*` ，不然会给字符串参数逐个字符推入一个列表。

```python
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("-f", "--foo", action="extend", nargs='*')
args = parser.parse_args()
print(args.foo)
```

```shell
python yourscript.py --foo 123 --foo 234 345 --foo
# ["123", "234", "345"]
```

### 指定不同的参数拼接到同一个列表

#### 简单拼接

只要 `dest` 指向同一个参数名称，且 `action` 为 `append` ，那么参数都会被收集到同一个列表。

```python
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("-f", "--foo", dest="foobar", action="append")
parser.add_argument("-b", "--bar", dest="foobar", action="append")
args = parser.parse_args()
print(args.foobar)
```

#### 不同的flag参数

只需将 `dest` 指向同一个参数名称， `action` 指定为 `append_const` ，flag参数就会被拼接到一个列表。flag参数在拼接为一个列表时，第一个参数的 `default` 值得是一个列表，用于拼接后续的值，以及在其中放上一个flag参数也不提供时的值列表。

并没有 `append_true` 或 `append_false` 这种行为将多个布尔值拼接到一个列表，这种情况只能用位运算进行模拟。

```python
import argparse

B_FOO = 0B01
B_BAR = 0B10

parser = argparse.ArgumentParser()
parser.add_argument("-f", "--foo",
    dest="foobar",
    action="append_const",
    const=B_FOO,
    default=[],
    )
parser.add_argument("-b", "--bar",
    dest="foobar",
    action="append_const",
    const=B_BAR,
    )
args = parser.parse_args()
mask = 0B00
for m in args.foobar:
    mask |= m
print(bin(mask)[2:].zfill(2))
```

```shell
python yourscript.py
# 00
python yourscript.py -f
# 01
python yourscript.py -f -b
# 11
```

### 参数计数

有时候可能希望通过类似这样的语法指定打印信息的等级 `-vvv` 为3，那么可以将 `action` 设置为 `count` 。

```python
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("-v", "--verbose", action="count", default=0)
args = parser.parse_args()
print(args.verbose)
```

```shell
python yourscript.py
# 0
python yourscript.py -vvv
# 3
```

### 版本号

一般Unix-Like系统下的程序程序除了都会有 `-h/--help` 之外，还有 `-v/--version` 用于查看软件版本，大家也通常用它来查看自己计算机上是否有安装对应的软件。

`action="version"` 与 `version="%(prog)s"` 是固定搭配，开发者可以在 `version` 中加些自定义的文本信息。

```python
import argparse

parser = argparse.ArgumentParser(prog="Hello")
parser.add_argument("-v", "--version",
    action="version",
    version="%(prog)s 特别版本。",
    )
args = parser.parse_args()
print(args.version)
```

```shell
python yourscript.py -v
# Hello 特别版本。
```

### 子命令

`argparse`  还可以制做子命令，类似于 `git commit` 、 `git add` 这类命令中， `commit` 和 `add` 就是子命令。

制做子命令的步骤如下：

1. 为根命令添加子parser列表。
2. 往子parser列表中添加子parser，并设置名称，该名称就是子命令的名称。
3. 为新添加的子parser添加事件处理函数，能够通过该函数识别出当前执行的是哪个子命令。

> parser的 `set_defaults` 方法可以设置一个默认值，其实就是提前往解析结果中加个特定名称的值 ，它的入参为解析结果的 `Namespace` ，我们提前给某个子命令的处理函数放进它的解析结果中，这样就可以通过 `args.func(args)` 智能地执行某个子命令下的逻辑，而不用根据所有参数来识别当前的子命令是哪个。

```python
import sys
import argparse

def func_add(args):
    print("Adding files")
    for f in args.files:
        print(f"add: {f}")

def func_commid(args):
    print(f"Commiting: {args.message}")

parser = argparse.ArgumentParser(prog="git", exit_on_error=False)
parser.add_argument("-v", "--version",
    action="version",
    version="%(prog)s 特别版本。",
    )
subparsers = parser.add_subparsers()

parser_add = subparsers.add_parser(name="add")
parser_add.add_argument("files", nargs='+')
parser_add.set_defaults(func=func_add)

parser_commit = subparsers.add_parser(name="commit")
parser_commit.add_argument("-m", "--message", required=True)
parser_commit.set_defaults(func=func_commid)

args = parser.parse_args()
args.func(args)
```

```shell
python yourscript.py add main.c utils.c
# Adding files
# add: main.c
# add: utils.c
python yourscript.py commit -m "some bug fix"
# Commiting: some bug fix
```
---

# getopt模块

## 概览

`getopt` 是一个非常精简的命令行参数解析模块，风格类似于Unix-Like系统下C语言常用的 `getopt` 库。它相比 `argparse` 虽然功能要少很多，但它 **简单易用** 。

`getopt` 模块主要的函数跟模块同名： `getopt.getopt` 。

### 语法

使用方式如下：

```python
opt, pos = getopt.getopt(args, options, [long_options])
```

#### 参数

- **args**
> 用户输入的参数列表，也就是 `sys.argv[1:]` 。

- **options**
> 一串「短名」构成的字符串，每个「短名」只能是一个字母，对于需要值的参数，应该以 `:` 结尾。每个「短名」前可以加 `-` 也可以不加，得到的结果是一样的。
> 例： `"-abx:y:z:"` ，该案例中有5个参数 `a` `b` `x` `y` `z`。

- **long_options**
> 一串「长名」的字符串列表，对于需要值的参数，应该以 `=` 结尾。每个「长名」前 **不可以** 加 `--` 。
> 例： `["condition", "compress-level="]` 。

#### 返回值

- **opt**
> 推导出来的「长名」、「短名」，与对应选项的值构成的列表。以 `(选项名称, 选项值)` 的元组形式存在。其中对于不需要值的选项而言 `选项值` 是个空字符串，对于需要值的选项而言是用户提供的字符串。
> 例： `[('-a', ''), ('-x', "3.14"), ('-y', "1024")]` 。

- **pos**
> 位置参数的值列表。
> 例： `[('--condition', ''), ('--compress-level', '6')]` 。

### 特性

#### 语法糖

 `getopt` 提供了一些贴心语法糖。

- --{Option}={Value}
> `argparse` 支持在提供带值选项时，以两种方式为选项提供值。方法一： `--option value` ；方法二： `--option=value` 。

#### 怪癖

 这里还会遇到一些Unix-Like下的“怪脾气”。

- options中的短参数只能有一个字母，不能是多个。
> `"-xyz:"` 会被当成 `x` 和 `y` 和 `z` ，其中只有 `z` 需要值。

- 位置参数只能放在所有选项的后面。
> 如果我们给选项放在位置参数后面，则选项的名称和值都会被当成位置参数中的一员。（argparse就不会有这样的问题）
> `prg main.c utils.c --verbose` 中的 `--verbose` 在解析完成后不会进入选项参数列表，它会被当成位置参数值的一员。

#### 功能缺失

`getopt` 相比于 `argparse` 还有不少功能的缺失。

1. 并没有强制要求用户提供某个参数的功能，只有约束某个参数是否强制要求值的功能。
2. 不会帮我们做参数的类型转换。
3. 没有办法做更具体的参数值数量约束。
4. 没有办法做「长名」和「短名」的绑定，全依赖于程序员自己在代码逻辑中做关联。

## 案例

### flag选项识别

由于 `getopt` 函数的返回值第一个元素是个元组构成的列表，它的格式天然适合直接转为字典，然后方便检查某个参数是否存在。

```python
import sys
import getopt

optlist, args = getopt.getopt(sys.argv[1:], 'h')
optdict = dict(optlist)
if "-h" in optdict:
    print("Hello World!")
```

```shell
python yourscript.py -h
# Hello World!
```

### 手动关联「长名」和「短名」

直接检查「长名」和「短名」中任意一个是否在字典中即可实现关联。

```python
import sys
import getopt

optlist, args = getopt.getopt(sys.argv[1:], 'h', ["help"])
optdict = dict(optlist)
if ("-h" in optdict) or ("--help" in optdict):
    print("Hello World!")
```

```shell
python yourscript.py -h
# Hello World!
python yourscript.py --help
# Hello World!
```

### 手动检查用户是否提供某个选项

```python
import sys
import getopt

optlist, args = getopt.getopt(sys.argv[1:], 'n:')
optdict = dict(optlist)
if not "-n" in optdict:
    raise ValueError("Please enter a number.")
print(f"Number: {optdict['-n']}")
```

```shell
python yourscript.py
# ValueError: Please enter a number.
```

### 手动约束选项的值数量

由于 `getopt` 函数的返回值第一个元素是个元组构成的列表，所以完全可以多次指定同一个选项的和它的值，然后手动给这些值收集到一个列表中。

```python
import sys
import getopt

optlist, args = getopt.getopt(sys.argv[1:], 'n:')
numbers = []
for name, value in optlist:
    if name == "-n":
        numbers.append(int(value))
if len(numbers) != 2:
    raise ValueError("You should provide 2 numbers.")
print(f"{numbers[0]} + {numbers[1]} = {sum(numbers)}")
```

```shell
python yourscript.py -n 1 -n 2
# 1 + 2 = 3
```

### 使用位置参数

```python
import sys
import getopt

optlist, args = getopt.getopt(sys.argv[1:], '', ["add", "sub"])
numbers = [float(s) for s in args]
opt = dict(optlist)
if "--add" in opt:
    if not len(numbers) > 0:
        raise ValueError("You should provide at least 1 number for addtion.")
    print(sum(numbers))
elif "--sub" in opt:
    if not len(numbers) > 1:
        raise ValueError("You should provide at least 2 number for subtraction.")
    print(numbers[0] - sum(numbers[1:]))
```

```shell
python yourscript.py --add 1 2 3
# 6.0
python yourscript.py --sub 6 1 2
# 3.0
```
