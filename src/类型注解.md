# 类型注解
# 为什么要有静态检查

在使用Python进行开发的时候，当项目扩张到一定程度，修改的代码就很难进行全量测试了，然而对于解释执行的脚本语言来说，
很多错误都只能在运行的时候才能发现，不像编译型语言可以在编译期解决掉绝大多数问题。

Python从3.5开始引入类型注解（Type Hint），在合适的位置加入数据类型注释，可以指引开发人员，还可以帮助IDE进行智能提示。
并且对于代码运行没有任何性能影响（非要说性能影响，无非也就是首次运行时编译的过程），
即使你的代码不遵守类型注解要求的数据类型。

使用诸如mypy这类静态检查工具检查的时候会对不匹配的类型进行报错，及时发现可能的风险。
mypy是一个Python第三方工具，通过命令行输入 `pip install mypy` 来安装。
其他静态检查工具有pyright、pylint等，各有各的功能长处。

```python
def add(a: int, b: int) -> int:
    return a + b

print(add(1, 3.14))
```

在Shell中输入命令，可以看到静态检查工具mypy会智能地将明显的类型不匹配错误报出来。

```powershell
mypy script.py
# error: Argument 2 to "add" has incompatible type "float"; expected "int"
```

但是并不影响运行

```powershell
python script.py
# 4.14
```

---

# 实例

## 简单数据类型注解

```python
# 整数
def add_i(a: int, b: int) -> int:
    return a + b

# 浮点数，能兼容整数
def add_f(a: float, b: float) -> float:
    return a + b

# 字符串
def strcat(a: str, b: str) -> str:
    return a + b
```

## 列表

Python的list是 **异构容器** ，一个容器里可以存放多个不同类型的数据。区别于C++、Jave等静态编程语言，
大多数标准容器是 **同构容器** ，一个容器里只能存放多个同类型的数据。Python中list容器的异构特性，
使得很多时候代码变得难以维护，可以用类型注解将异构容器标记为同构容器，用于指示后续的开发人员。

另外注意，使用列表的一个主要原因是它能够任意改变长度，里面可能会保存大量的数据，
所以类型注解并没有提供一个机制用于标记列表的长度。

`list` 单独使用表示任意长度的异构列表。
`list[T]` 表示任意长度的指定类型元素的同构列表。

另外，标准库的typing模块也提供了 `List` ，和直接用 `list` 注解效果是一致的，推荐使用标准库提供的 `List` 进行标注。

```python
from typing import List

# 此处foo接受一个int参数，返回任意长度的异构列表
def foo(num: int) -> list:
    return [num] * 3

# 此处bar接受一个int参数，返回任意长度的异构列表，List和list注解作用完全一致
def bar(num: int) -> List:
    return [num] * 3

# 此处spam接受一个int参数，返回任意长度元素类型都是int的同构列表
def spam(num: int) -> List[int]:
    return [num] * 3
```

## 元组

Python的tuple与list一样，也是 **异构容器** 。只不过tuple的使用，即使在C++里面，也经常是作为异构容器来使用的，
很多时候倾向于面对已知且有限长度的不同数据组合。比如`(名称, 年纪)`，我们知道他的长度为2，元素类型分别为字符串、整数。

在注解元组的过程中，可以将元组标记为任意长度的异构容器，或者有限长度且指定了各个元素类型的异构容器，
**但是无法注解为任意长度的同构元组** 。

`tuple` 单独使用表示任意长度的异构元组。
`tuple[T1, T2, T3, ...]` 表示指定数量、类型的异构元组。

另外，标准库的typing模块也提供了 `Tuple` ，和直接用 `tuple` 注解效果是一致的，推荐使用标准库提供的 `Tuple` 进行标注。

```python
from typing import Tuple

# 此处foo接受一个int参数，返回任意长度的异构元组
def foo(num: int) -> tuple:
    return (num,) * 3

# 此处bar接受一个int参数，返回任意长度的异构元组，Tuple和tuple注解作用完全一致
def bar(num: int) -> Tuple:
    return (num,) * 3

# 此处bar接受一个int参数，返回类型注解Tuple[int]表示的不是任意长度的int同构元组
# 而是只包含一个int类型数据的元组
def spam(num: int) -> Tuple[int]:
    return (num,)

# Tuple[str, int, float]表示一个包含三个元素的元组，三个元素的类型分别是str, int, float
def eggs(name: str, age: int, stature: float) -> Tuple[str, int, float]:
    return (name, age, stature)

# 为了方便，还可以使用类型Alias
Baz = Tuple[str, int, float]
def baz(name: str, age: int, stature: float) -> Baz:
    return (name, age, stature)
```

## 集合

注解在集合身上的作用就是让异构集合变成同构集合，但是有个要求就是集合的元素都必须是可哈希的。

`set` 单独使用表示任意长度的集合。
`set[T]` 表示任意长度的指定类型元素的集合。

另外，标准库的typing模块也提供了 `Set` ，和直接用 `set` 注解效果是一致的，推荐使用标准库提供的 `Set` 进行标注。

```python
from typing import Set

# 此处foo接受一个int参数，返回任意长度的异构集合
def foo(num: int) -> set:
    return set(range(num))

# 此处foo接受一个int参数，返回任意长度的异构集合，Set和set注解作用完全一致
def bar(num: int) -> Set:
    return set(range(num))

# 此处spam接受一个int参数，返回任意长度的同构集合，Set和set注解作用完全一致
def spam(num: int) -> Set[int]:
    return set(range(num))
```

## 字典

注解在字典身上的作用就是让异构字典变成同构字典，但是有个要求就是字典的键都必须是可哈希的，值的类型无所谓。

使用 `dict[TK, TV]` 来定义字典的类型信息。

另外，标准库的typing模块也提供了 `Dict` ，和直接用 `dict` 注解效果是一致的，推荐使用标准库提供的 `Set` 进行标注。

```python
from typing import Dict

def print_pairs1(d: dict[str, int]):
    for k, v in d.items():
        print(k, v)

def print_pairs2(d: Dict[str, int]):
    for k, v in d.items():
        print(k, v)

print_pairs1({"A": 1, "B": 2, "C": 3})
print_pairs2({"D": 4, "F": 5, "G": 6})
```

## 任意类型序列

任意类型序列是指有序序列，比如列表、元组等，他们都是 `collections.abc.Sequence` 的虚子类。
所谓虚子类，意思就是他们和某个类型并不真实存在继承关系，因为它们可能是C语言编写的原生类型之一，
只是符合某个接口类型的协议规范而做的非硬性分类，比如序列都得支持下标索引、都得支持迭代、得是有序存储。

```python
from collections.abc import Sequence

def print_seq(seq: Sequence) -> None:
    for i in seq:
        print(i)

def print_seqi(seq: Sequence[int]) -> None:
    for i in seq:
        print(i)

def print_seqf(seq: Sequence[float]) -> None:
    for i in seq:
        print(i)

print_seq([1, 2, 3])
print_seqi((1, 2, 3))
print_seqf((1.0, 2.0, 3.0))
```

## 任意类型可迭代对象

集合无序所以不算序列，但是它可以使用 `collections.abc.Iterable` 进行注解，因为它是可迭代对象，
是 `collections.abc.Iterable` 的虚子类。

```python
from collections.abc import Iterable

def print_iterable(seq: Iterable) -> None:
    for i in seq:
        print(i)

print_iterable({1.0, 2.0, 3.0})
print_iterable({1: 1.0, 2: 2.0, 3: 3.0})

```

## 可调用类型

Callable类型用于注解某个可调用对象，类似于C语言的函数指针、C++的函数对象。注解语法是一个列表，里面有两个元素，
第一个元素是函数的参数类型列表，第二元素是函数的返回值类型。Python的函数即使没有返回值，其也是默认返回None，
所以Callable注解一定会有第二个元素表示其返回类型。

使用`Callable[[T1, T2, T3, ...], TRet]`来定义可调用对象的类型信息。

```python
from typing import Tuple
from typing import Callable

# 简单点的例子
def add(a: int, b: int) -> int:
    return a + b

def sub(a: int, b: int) -> int:
    return a - b

def apply_function(func: Callable[[int, int], int], a: int, b: int) -> int:
    return func(a, b)

apply_function(add, 1, 2)
apply_function(sub, 1, 2)

# 复杂点的例子
def func1(a: int, b: int) -> Tuple[int, int]:
    return a + b, a - b

def func2(a: int, b: int) -> Tuple[int, int]:
    return a - b, a + b

def process(
    func1: Callable[[int, int], Tuple[int, int]],
    func2: Callable[[int, int], Tuple[int, int]],
    a: int,
    b: int,
    ) -> Tuple[int, int]:
    res1, res2 = func1(a, b)
    res3, res4 = func2(a, b)
    return res1 + res2, res3 + res4

process(func1, func2, 1, 2)
```

## 混合类型

有时候数据的类型可能是好几种类型中的一种，可以使用Union来实现混合类型。

Union的参数列表可以放入多个数据类型： `Union[T1, T2, T3, ...]` 。

```python
from typing import Union

def introduce(name: str, age: Union[int, None]) -> str:
    return "My name is {0}, I'm {1} years old.".format(
            name,
            age if (not age is None) else "unknown"
            )

introduce("Foo", 27)
introduce("Bar", None)
```

Python3.10还提供了类似集合的“并”操作来产生混合类型。

```python
def add(num1: int | float, num2: int | float) -> int | float:
    return num1 + num2

isinstance(3.14, int | float) # True
```
## 可选类型

Optional用于表示某个参数是可省略的参数。
Optional的参数列表只可以放入一个数据类型： `Optional[T]` 。

`Optional[T]` 相当于 `Union[T, None]` 。

```python
from typing import Union
from typing import Optional

def introduce(name: str, age: Optional[int]=None) -> str:
    return "My name is {0}, I'm {1} years old.".format(
            name,
            age if (not age is None) else "unknown"
            )

introduce("Foo", 27)
introduce("Bar")
```

## 任意类型

如果指定的参数或返回值会是任意类型，可以使用Any类型。但是不建议大量使用，这样会导致静态检查器难以分析出确定的bug，
约等于没有注解。

```python
from random import randint
from typing import Any

def random(seed: int) -> Any:
    lut = [123, 3.14, "Hello World"]
    return lut[seed % len(lut)]

random(randint(0, 255))
```

## NoneType类型

None的类型虽然是NoneType，它在types模块里，但是不需要用NoneType进行注解，直接使用None即可。

```python
def nothing(anything: None):
    pass

nothing(None)
```

## 不返回的函数

有时候可能需要标明一个函数可能永远不会返回、会抛出异常、会调用`sys.exit()`，可以用NoReturn。

```python
from typing import NoReturn

def raise_error(message: str) -> NoReturn:
    raise ValueError(message)

raise_error("some error")
```

## 命名元组

`collections` 里面有个 `namedtuple` ，而 `typing` 里面有个 `NamedTuple` 。前者类似于弱类型命名元组，
后者可以得到类似强类型命名元组的效果。NamedTuple对于严格遵守静态检查器要求的程序员而言，
更类似于C、C++中强类型的的结构体。

```python
# 弱类型命名元组
from collections import namedtuple
LoosePoint = namedtuple("LoosePoint", ["x", "y"])
lp1 = LoosePoint(32, "64")
lp2 = LoosePoint("32", 64)

# 强类型命名元组
from typing import NamedTuple
Point = NamedTuple('Point', [('x', int), ('y', int)])
p1 = Point(32, 64)
p2 = Point(x = 128, y = 256)
```

## 命名字典

命名字典也具有类似强类型结构体的效果。

```python
from typing import TypedDict

class Point2D(TypedDict):
    x: int
    y: int
    label: str

a: Point2D = {'x': 1, 'y': 2, 'label': 'good'}  # OK
b: Point2D = {'z': 3, 'label': 'bad'}           # Fails type check

assert Point2D(x=1, y=2, label='first') == dict(x=1, y=2, label='first')
```

## 定义新类型

有时候为某个现有的类型，起一个别名，对项目而言会更有指导意义。

Python3.10提供的一种方法是使用TypeAlias。

```python
Baz = Tuple[str, int, float]
def baz(name: str, age: int, stature: float) -> Baz:
    return (name, age, stature)
```

另一种方法是使用 `typing` 模块提供的 `NewType` 。

```python
from typing import NewType

UserId = NewType('UserId', int)

a = UserId(32)
b = UserId(64)
print(a + b) # 96

# 静态检查会失败，因为UserId只是模拟了一个Callable对象，而非真正的类型
# class Admin(UserId):pass

# 但是可以用NewType来模拟继承
Admin = NewType("Admin", UserId)
admin = Admin(UserId(1))
```

## 限定范围的字面量

使用Literal可以限定数据类型在指定的几个字面量范围内，不可以是变量，必须是手动输入的字符串字面量。

```python
from typing import IO
from typing import Any
from typing import Literal
from typing import Optional

FileIOMode = Literal["r", "w", "rb", "wb"]

def file_io_helper(path: str, mode: FileIOMode = "r") -> IO[Any]:
    return open(path, mode)

fp = file_io_helper("script.py", "r")
print(fp.read())
fp.close()

DEVMODE = Literal[1, 2, 4]
def dev_mode(mode: DEVMODE) -> DEVMODE:
    return mode
```

_Python3.11还新增了LiteralString，可以用于表示参数必须是字符串字面量。_

## 类型本身而非类型的实例

常规类型注解都表示该类型实例，如果是类型本身呢，用 `Type["cls"]` 。

```python
from typing import Type

class A:

    @classmethod
    def inst(cls: Type["A"]) -> "A":
        return cls()

def print_A(cls: Type[A]):
    print(cls)

def print_a(ins: A):
    print(ins)

a = A.inst()
print_A(A)
print_a(a)
```

## 函数重载

Python本身是不支持函数重载的，只能运行时根据参数类型的组合确定代码执行哪个分支。typing提供了一个伪函数重载的支持，
仅用于提示程序员和IDE。主要方式就是先定义不同函数重载的注解，最后再定义函数本身的实现，
这样实际的实现就被最后一个函数定义所覆盖，但是前面的注解已经被 `overload` 装饰器所收集。

```python
from typing import overload

class A:

    @overload
    def __init__(self, age: int):
        ...

    @overload
    def __init__(self, name: str):
        ...

    def __init__(self, age_or_name):
        if isinstance(age_or_name, int):
            print("Age of: %d" % age_or_name)
        elif isinstance(age_or_name, str):
            print("Name of: %s" % age_or_name)

A(123) # Age of: 123
A("foo") # Name of: foo
```

## 禁止重载或继承

typing中的final装饰器装饰过的方法将无法被重写，被final装饰过的类将无法被继承。

```python
from typing import final

class A:

    @final
    def say(self) -> None:
        print("I'm A")

class B(A):

    def say(self) -> None: # Error
        print("I'm B")

@final
class C:...

class D(C):... # Error
```

## 接口

面向接口编程，也就是约束实践中的操作来符合某个规范，比如类必须实现哪些方法、函数必须得是什么参数列表。
可以用接口类继承Protocal，并且一旦使用了 `runtime_checkable` 装饰了接口类，
实现了接口类的实例就可以在运行时使用 `isinstance` 和 `issubclass` 。

```python
from typing import Protocol
from typing import runtime_checkable

@runtime_checkable
class IPerson(Protocol):

    def name(self) -> str:
        ...

    def age(self) -> int:
        ...

class Student:

    def __init__(self, name, age):
        self.__name = name
        self.__age = age

    def name(self) -> str:
        return self.__name

    def age(self) -> int:
        return self.__age

def print_person(p: IPerson) -> None:
    name = p.name()
    age = p.age()
    clsname = type(p).__name__
    print(f"<{clsname}: {name} {age}>")

stu = Student("Foo", 27)
print_person(stu)
print(isinstance(stu, IPerson)) # True
```

## 类方法中注解类本身

遇到在类的方法中使用类本身作为类型注解，或者类与类的循环依赖，会引发类型不存在的错误，不仅静态检查无法通过，
解释器执行的时候都会报错，因为到类的代码执行完成之前，类还没真正诞生。

这种行为叫做 **forward-referencing** ，可以使用 `"ClassName"` 来表示即将出现的类。

```python
class A:

    __instance = None

    @classmethod
    def instance(cls) -> "A": # 如果用A而不是"A"的话会引发名称错误
        if not cls.__instance:
            cls.__instance = cls()
        return cls.__instance

a = A.instance()
```

遇到循环依赖的情况，也是一样的处理方式。

```python
from typing import Set

class Server:

    def __init__(self) -> None:
        self.__clients: Set["Client"] = set()

    def clients(self) -> Set["Client"]:
        return self.__clients

    def add_client(self, client: "Client") -> None:
        self.__clients.add(client)

class Client:

    def __init__(self, cid: int) -> None:
        self.__cid: int = cid

    def connect(self, server: "Server") -> None:
        server.add_client(self)

    def __repr__(self) -> str:
        return f"<Client: {self.__cid}>"

server: Server = Server()
client1: Client = Client(1)
client2: Client = Client(2)
client1.connect(server)
client2.connect(server)
print(server.clients())
```

Python3.7以后，也可以用 `from __future__ import annotations` 来假装类存在。

```python
# Python3.7+

from __future__ import annotations

class A:

    __instance = None

    @classmethod
    def instance(cls) -> A:
        if not cls.__instance:
            cls.__instance = cls()
        return cls.__instance

a = A.instance()
```

Python3.11在typing中提供了 `Self` 类型，用于表示类本身。

```python
# Python3.11

from typing import Self

class A:

    __instance = None

    @classmethod
    def instance(cls) -> Self:
        if not cls.__instance:
            cls.__instance = cls()
        return cls.__instance

a = A.instance()
```

## 临时关闭检查

有时候有一些特定环境下才会存在的类型，需要临时关闭检查。

* **忽略单行代码** ：可以在行尾注释中写上 `# type: ignore` ，就会忽略该行的检查。

```python
import rt # type: ignore

class MyType(rt.Geometry):

  def __init__(self, name: str, geo: rt.Geometry) -> None:
      self.__name = name

mt = MyType("Foo", rt.Geometry())
```

* **忽略函数或方法** ：可以使用typing中的装饰器 `no_type_check` 装饰器来忽略具体代码块的检查。

```python
@no_type_check
def error_function(param: int) -> int:
  var: str = param
  return var
```
