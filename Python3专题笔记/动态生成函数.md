动态生成函数
================================================================================

__测试版本__：Python3.10.8

--------------------------------------------------------------------------------

### Python中动态生成函数可以使用 `lambda` 关键字。

```python
def func_gen(hint):
    assert hint in ("-" , "+")
    if hint == "-":
        return lambda a, b: a - b
    else:
        return lambda a, b: a + b

sub = func_gen("-")
add = func_gen("+")
sub(1, 2) # -1
add(1, 2) # 3
```

### 在循环中动态生成函数的常见错误

```python
# 错误代码

def func_gen(n):
    res = []
    for i in range(n):
        res.append(lambda: i * i)
    return res

funcs = func_gen(3)
for f in funcs:
    print(f(), end=" ")
# 4 4 4
```

并没有按预期打印出 `0 1 4` ，是因为 `func_gen` 中的 `lambda` 绑定的是循环中的迭代变量 `i` ，函数执行完成后， `i` 停留在了 `2` 。

Python中的作用域分为三种：__global__ 、 __local__ 、 __nonlocal__。global永远不会结束生命周期。local是函数的形参和局部变量，离开函数后就结束生命周期。按照local的规则，函数内动态生成的函数应该访问不到 `i` 了才对，因为 `func_gen` 执行完毕后 `i` 就死亡了，但事实上 `i` 并没内有被放在local中，而是nonlocal。

```mermaid
graph LR
A(global) B(local) C(nonlocal)
```

Python在执行函数的过程中，为了加速局部变量的访问，会在栈帧中将局部变量、函数的参数放入叫 __fast__ 的块中，按索引快速访问，对应 __local__ 类型变量；将闭包将会引用到的变量放入 __deref__ 的块中，对应 __nonlocal__ 类型变量。当函数执行完毕后，fast内的内容宣布消亡，但deref会一直存在，以至于动态生成的函数依然能够访问到。

为了让函数的返回值分别是 `0 1 4` ，我们需要另一条规则：函数的默认参数是在函数定义时赋值的。

```python
# 正确代码

def func_gen(n):
    res = []
    for i in range(n):
        res.append(lambda v=i: v * v)
    return res

funcs = func_gen(3)
for f in funcs:
    print(f(), end=" ")
# 0 1 4
```
